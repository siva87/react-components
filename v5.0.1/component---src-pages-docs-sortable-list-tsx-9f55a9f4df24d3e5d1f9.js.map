{"version":3,"file":"component---src-pages-docs-sortable-list-tsx-9f55a9f4df24d3e5d1f9.js","mappings":"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","sources":["webpack://react-components-docs/../lib/src/SortableList/SortableList.tsx","webpack://react-components-docs/../lib/src/SortableList/SortableItem.tsx","webpack://react-components-docs/./src/pages/docs/sortable-list.tsx","webpack://react-components-docs/../lib/src/SortableList/dragtouch.polyfills.ts","webpack://react-components-docs/../lib/src/SortableList/SortableList.tsx?e347"],"sourcesContent":["import React from \"react\";\nimport classnames from \"classnames\";\nimport { SortableItemProps } from \"./SortableItem\";\nimport \"./dragtouch.polyfills\";\nimport \"./sortable-list.scss\";\n\nconst dragAndDropIcon: JSX.Element = (\n    <svg width=\"10px\" fill=\"currentColor\" height=\"16px\" viewBox=\"0 0 10 16\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlnsXlink=\"http://www.w3.org/1999/xlink\">\n        <g id=\"Symbols\" stroke=\"none\" strokeWidth=\"1\" fill=\"none\" fillRule=\"evenodd\">\n            <g id=\"Group\" fill=\"currentColor\">\n                <circle id=\"Oval\" cx=\"2\" cy=\"2\" r=\"2\" />\n                <circle id=\"Oval-Copy-2\" cx=\"2\" cy=\"8\" r=\"2\" />\n                <circle id=\"Oval-Copy-4\" cx=\"2\" cy=\"14\" r=\"2\" />\n                <circle id=\"Oval-Copy\" cx=\"8\" cy=\"2\" r=\"2\" />\n                <circle id=\"Oval-Copy-3\" cx=\"8\" cy=\"8\" r=\"2\" />\n                <circle id=\"Oval-Copy-5\" cx=\"8\" cy=\"14\" r=\"2\" />\n            </g>\n        </g>\n    </svg>\n);\n\nexport type SortableListProps = JSX.IntrinsicElements[\"div\"] & {\n    /** on sort callback */\n    onSort: (list: Array<string>) => void;\n    /** disable sorting */\n    disabled?: boolean;\n};\n\ntype PositionDelta = {\n    x: number;\n    y: number;\n};\n\ntype OrderItem = Pick<SortableItemWrapperProps, \"disabled\" | \"uniqueKey\">;\n\n/** The component allows for sorting list by drag and drop. */\nexport const SortableList: React.FC<SortableListProps> = ({ onSort, className, disabled, ...props }: React.PropsWithChildren<SortableListProps>) => {\n    const dragContainerRef = React.useRef<HTMLDivElement>();\n    const [defaultOrders, setDefaultOrders] = React.useState<OrderItem[]>([]);\n    const [draggingOrders, setDraggingOrders] = React.useState<OrderItem[]>(defaultOrders);\n    const [currentItemNode, setCurrentItemNode] = React.useState<HTMLDivElement>(null);\n    const [currentItemIndex, setCurrentItemIndex] = React.useState<number>(null);\n    const [delta, setDelta] = React.useState<PositionDelta>({ x: 0, y: 0 });\n    const [dragNode, setDragNode] = React.useState<HTMLElement>(null);\n    const [isDragging, setIsDragging] = React.useState<boolean>(false);\n    const [isTranslating, setIsTranslating] = React.useState<boolean>(false);\n    const [affectedIndex, setAffectedIndex] = React.useState<number>(null);\n    const [affectedNode, setAffectedNode] = React.useState<HTMLDivElement>(null);\n\n    /**\n     * when user clicks on sortable item, set initial delta and selected item\n     * @param event mouse event\n     * @param index selected index\n     */\n    const onMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>, index: number) => {\n        const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\".sortable-item-wrapper\");\n        const position: React.MouseEvent = ((event as React.TouchEvent).touches ? (event as React.TouchEvent).touches[0] : event) as React.MouseEvent;\n        setDelta({\n            x: position.pageX - itemParentNode.getBoundingClientRect().left,\n            y: position.pageY - itemParentNode.getBoundingClientRect().top,\n        });\n        setCurrentItemIndex(index);\n        setCurrentItemNode(itemParentNode);\n    };\n\n    /**\n     * on drag initiated, set the ghost item\n     * @param event drag event\n     */\n    const onDragStart = React.useCallback(\n        (event: React.DragEvent<HTMLDivElement>) => {\n            setIsDragging(() => {\n                const clonedNode: HTMLElement = currentItemNode.cloneNode(true) as HTMLElement;\n                clonedNode.classList.remove(\"is-active\");\n                clonedNode.classList.add(\"on-drag\");\n                clonedNode.style.width = `${currentItemNode.getBoundingClientRect().width}px`;\n                clonedNode.style.height = `${currentItemNode.getBoundingClientRect().height}px`;\n                document.body.appendChild(clonedNode);\n                event.dataTransfer.setDragImage(clonedNode, delta.x, delta.y);\n                event.dataTransfer.effectAllowed = \"move\";\n                setDragNode(clonedNode);\n                return true;\n            });\n        },\n        [currentItemNode]\n    );\n\n    /**\n     * when the dragged item is dragged over another sortable item, check if the overlapped element fulfills criteria to be swapped\n     * @param event drag event\n     * @param index overlapped index\n     */\n    const onDragOver = React.useCallback(\n        (event: React.DragEvent<HTMLDivElement>, index: number) => {\n            event.preventDefault(); // to prevent ghost image for reverting to original position\n            event.dataTransfer.dropEffect = \"move\";\n            const activeNodeRect: DOMRect = currentItemNode.getBoundingClientRect();\n            const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\".sortable-item-wrapper\");\n            const nodeRect: DOMRect = itemParentNode.getBoundingClientRect();\n            const ghostImagePositionTop: number = event.clientY - delta.y;\n            const ghostImagePositionBottom: number = ghostImagePositionTop + activeNodeRect.height; // get ghost image's actual position\n            const isAboveGhostImage: boolean = nodeRect.top <= ghostImagePositionTop;\n            let positionDifference: number = nodeRect.top - ghostImagePositionBottom;\n            if (isAboveGhostImage) {\n                positionDifference = ghostImagePositionTop - nodeRect.bottom;\n            }\n            const isHalfCoverage: boolean = Math.abs(positionDifference) / nodeRect.height >= 0.5; // only trigger swapping when overlapped coverage is more than 50%\n            const isOverlapped: boolean = isHalfCoverage && !isTranslating && itemParentNode.className.indexOf(\"on-drag\") === -1;\n            itemParentNode.style.transform = null;\n            if (isOverlapped) {\n                // if the overlapped item fulfills criteria, initiate animation\n                setIsTranslating(true);\n                itemParentNode.style.transform = `translate3d(0, ${isAboveGhostImage ? \"\" : \"-\"}${itemParentNode.offsetHeight}px, 0)`;\n                setAffectedNode(itemParentNode);\n                setAffectedIndex(index);\n            }\n        },\n        [currentItemNode, delta, setIsTranslating, setAffectedNode, setAffectedIndex]\n    );\n\n    /** sort dragging order on transition end */\n    const onTransitionEnd = React.useCallback(() => {\n        if (affectedNode) {\n            setDraggingOrders((oldOrders: OrderItem[]) => {\n                const newList: OrderItem[] = oldOrders.slice(0);\n                affectedNode.style.transform = null;\n                let itemIndex: number = currentItemIndex;\n                const originalItem: OrderItem = newList.find(({ uniqueKey }: OrderItem, index: number) => {\n                    itemIndex = index;\n                    return uniqueKey === defaultOrders[currentItemIndex].uniqueKey;\n                });\n                newList[itemIndex] = newList[affectedIndex]; // swap overlapped\n                newList[affectedIndex] = originalItem;\n                setAffectedIndex(null);\n                setAffectedNode(null);\n                setIsTranslating(false);\n                return newList;\n            });\n        }\n    }, [affectedNode, affectedIndex, setDraggingOrders, setAffectedIndex, setAffectedNode, setIsTranslating]);\n\n    /**\n     * on drag end, remove appended ghost image and style, fire on sort callback\n     * @param event drag event\n     */\n    const onDragEnd = React.useCallback(\n        (event: React.DragEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>) => {\n            setIsDragging(() => {\n                event.preventDefault(); // to prevent ghost image for reverting to original position\n                event.stopPropagation();\n                Array.from(dragContainerRef.current.children).forEach((element: HTMLElement) => {\n                    element.style.transform = null;\n                });\n                setCurrentItemIndex(null);\n                setCurrentItemNode(null);\n                onSort(draggingOrders.map(({ uniqueKey }: OrderItem) => uniqueKey));\n                setDefaultOrders(draggingOrders);\n                dragNode?.remove();\n                return false;\n            });\n        },\n        [dragContainerRef, draggingOrders, dragNode, setIsDragging, setCurrentItemIndex, setCurrentItemNode, onSort, setDefaultOrders]\n    );\n\n    React.useEffect(() => {\n        setDefaultOrders(() => {\n            const newOrderList: OrderItem[] = React.Children.toArray(props.children)\n                .filter((item: React.ReactChild) => React.isValidElement<React.FC<SortableItemProps>>(item) && (item?.type as any)?.displayName === \"SortableItem\")\n                .map(({ props }: React.ReactElement<SortableItemProps>) => ({ uniqueKey: props.uniqueKey, disabled: props.disabled }));\n            if (newOrderList.length === 0) {\n                console.warn(\"Please pass at least one SortableItem element to make SortableList works\");\n            }\n            return newOrderList;\n        });\n    }, [props.children]);\n\n    React.useEffect(() => {\n        setDraggingOrders(defaultOrders);\n    }, [defaultOrders]);\n\n    return (\n        <div {...props} className={classnames(\"rc\", \"sortable-list\", className, { disabled })}>\n            <div className=\"drop-container\" ref={dragContainerRef}>\n                {(currentItemIndex === null ? defaultOrders : draggingOrders).map((item: OrderItem, index) => (\n                    <SortableItemWrapper\n                        key={index}\n                        uniqueKey={item.uniqueKey}\n                        disabled={disabled || item.disabled}\n                        isActive={currentItemIndex !== null && item === defaultOrders[currentItemIndex]}\n                        isDragging={isDragging}\n                        className=\"sortable-item-wrapper\"\n                        onMouseDown={(event: React.MouseEvent<HTMLDivElement, MouseEvent>) => onMouseDown(event, index)}\n                        onTouchStart={(event: React.TouchEvent<HTMLDivElement>) => onMouseDown(event, index)}\n                        onMouseUp={onDragEnd}\n                        onTouchEnd={onDragEnd}\n                        onDragStart={onDragStart}\n                        onDragOver={isTranslating ? null : (event: React.DragEvent<HTMLDivElement>) => onDragOver(event, index)}\n                        onDragEnd={onDragEnd}\n                        onTransitionEnd={onTransitionEnd}\n                    >\n                        {React.Children.map(props.children, (Child: React.ReactElement<SortableItemProps>) => {\n                            const { uniqueKey }: SortableItemProps = Child.props;\n                            const isDisabled: boolean = disabled || item.disabled;\n                            return item.uniqueKey === uniqueKey && React.isValidElement<React.FC<SortableItemProps>>(Child)\n                                ? React.cloneElement(Child, {\n                                      disabled: isDisabled,\n                                      \"aria-disabled\": isDisabled,\n                                  })\n                                : null;\n                        })}\n                    </SortableItemWrapper>\n                ))}\n            </div>\n        </div>\n    );\n};\n\ntype SortableItemWrapperProps = SortableItemProps &\n    JSX.IntrinsicElements[\"div\"] & {\n        isActive?: boolean;\n        disabled?: boolean;\n        isDragging?: boolean;\n    };\n\nconst SortableItemWrapper: React.FC<SortableItemWrapperProps> = ({\n    isActive,\n    isDragging,\n    className,\n    disabled,\n    children,\n    uniqueKey,\n    onDragStart,\n    onDragOver,\n    onDragEnd,\n    onTransitionEnd,\n    onMouseDown,\n    onMouseUp,\n    onTouchEnd,\n    onTouchStart,\n    ...props\n}: React.PropsWithChildren<SortableItemWrapperProps>) => {\n    return (\n        <div\n            {...props}\n            className={classnames(\"rc\", \"sortable-item-wrapper\", className, { \"is-active\": isActive && isDragging, disabled })}\n            data-value={uniqueKey}\n            onTransitionEnd={disabled ? null : onTransitionEnd}\n            onDragOver={disabled ? null : isActive ? (event: React.DragEvent) => event.preventDefault() : onDragOver}\n        >\n            <div className=\"sort-item-content\">{children}</div>\n            <div\n                className=\"drag-icon\"\n                draggable={isActive && !disabled}\n                onMouseUp={isDragging || disabled ? null : onMouseUp}\n                onTouchEnd={isDragging || disabled ? null : onTouchEnd}\n                onMouseDown={disabled ? null : onMouseDown}\n                onTouchStart={disabled ? null : onTouchStart}\n                onDragStart={isActive || !disabled ? onDragStart : null}\n                onDragEnd={isDragging || !disabled ? onDragEnd : null}\n            >\n                {dragAndDropIcon}\n            </div>\n        </div>\n    );\n};\n","import React from \"react\";\nimport classnames from \"classnames\";\n\nexport type SortableItemProps = Omit<JSX.IntrinsicElements[\"div\"], \"onDragStart\" | \"onDragOver\" | \"onDragEnd\"> & {\n    uniqueKey: string;\n    disabled?: boolean;\n};\n\nconst SortableItem: React.FC<SortableItemProps> = React.forwardRef(\n    ({ className, disabled, children, uniqueKey, ...props }: React.PropsWithChildren<SortableItemProps>, ref: React.ForwardedRef<HTMLDivElement>) => {\n        return (\n            <div {...props} ref={ref} className={classnames(\"rc\", \"sortable-item\", className)}>\n                {React.Children.map(children, (Child: React.ReactElement) => {\n                    const isDisabled: boolean = disabled || Child.props?.disabled;\n                    return React.isValidElement<React.FC<any>>(Child)\n                        ? React.cloneElement(Child, {\n                              disabled: isDisabled,\n                              \"aria-disabled\": isDisabled,\n                          } as any)\n                        : Child;\n                })}\n            </div>\n        );\n    }\n);\n\nSortableItem.displayName = \"SortableItem\";\n\nexport { SortableItem };\n","import React from \"react\";\nimport Docs from \"@common/Docs\";\nimport { SortableList } from \"@sebgroup/react-components/SortableList\";\nimport { useDynamicForm } from \"@sebgroup/react-components/hooks/useDynamicForm\";\nimport { SortableItem } from \"@sebgroup/react-components/SortableList/SortableItem\";\nimport { Checkbox } from \"@sebgroup/react-components/Checkbox\";\n\nconst importString: string = require(\"!raw-loader!@sebgroup/react-components/SortableList/SortableList\");\nconst code: string = `<SortableList>\n    <SortableItem uniqueKey=\"item1\">item 1</SortableItem>\n    <SortableItem uniqueKey=\"item2\">item 2</SortableItem>\n    <SortableItem uniqueKey=\"item3\" disabled>item 3</SortableItem>\n</SortableList>`;\n\ntype Example = {\n    label: string;\n    value: string;\n    checked: boolean;\n    disabled?: boolean;\n};\n\nconst SortableListPage: React.FC = (): React.ReactElement<void> => {\n    const [value, setValue] = React.useState<number>(null);\n    const [array, setArray] = React.useState<Example[]>([\n        {\n            label: \"Name\",\n            value: \"1\",\n            checked: false,\n        },\n        {\n            label: \"Age\",\n            value: \"2\",\n            checked: false,\n        },\n        {\n            label: \"Company\",\n            value: \"3\",\n            checked: false,\n        },\n        {\n            label: \"Address\",\n            value: \"4\",\n            checked: false,\n        },\n    ]);\n\n    const [renderControls, { controls }] = useDynamicForm([\n        {\n            key: \"controls\",\n            items: [\n                { key: \"disabled\", label: \"disabled\", controlType: \"Checkbox\" },\n                { key: \"disabledItem\", label: \"disable one random item\", controlType: \"Checkbox\" },\n                { key: \"simple\", label: \"simple usage\", controlType: \"Checkbox\" },\n            ],\n        },\n    ]);\n\n    React.useEffect(() => {\n        setValue(controls.disabledItem ? Math.floor(Math.random() * (array.length - 1 - 0 + 1)) + 0 : null);\n    }, [controls.disabledItem]);\n\n    return (\n        <Docs\n            mainFile={importString}\n            example={\n                <div className=\"w-100 d-flex justify-content-center\">\n                    <SortableList\n                        disabled={controls.disabled}\n                        onSort={(list: string[]) => setArray((oldArray: Example[]) => oldArray.sort((a: Example, b: Example) => list.indexOf(a.value) - list.indexOf(b.value)))}\n                    >\n                        {array.map((item: Example, index: number) => (\n                            <SortableItem key={index} uniqueKey={item.value} disabled={index === value}>\n                                {controls.simple ? (\n                                    item.label\n                                ) : (\n                                    <Checkbox\n                                        name=\"test\"\n                                        value={item.value}\n                                        checked={item.checked}\n                                        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {\n                                            setArray((oldArray: Example[]) =>\n                                                oldArray.map((checkbox: Example) => ({\n                                                    ...checkbox,\n                                                    checked: item.value === checkbox.value ? event.target.checked : checkbox.checked,\n                                                }))\n                                            );\n                                        }}\n                                    >\n                                        {item.label}\n                                    </Checkbox>\n                                )}\n                            </SortableItem>\n                        ))}\n                    </SortableList>\n                </div>\n            }\n            code={code}\n            controls={<>{renderControls()}</>}\n        />\n    );\n};\n\nexport default SortableListPage;\n","// tslint:disable\n/**\n * drag drop touch polyfill from https://github.com/Bernardo-Castilho/dragdroptouch/blob/master/DragDropTouch.js\n * credits to: https://github.com/Bernardo-Castilho\n */\n// This solution is meant to fix Gatsby build which complains that document doesn't exist in server-side rendering\nconst safeDocument: Document | null = typeof document !== \"undefined\" ? document : null;\nconst safeNavigator: Navigator | null = typeof navigator !== \"undefined\" ? navigator : null;\nvar DragDropTouch;\n(function (DragDropTouch_1) {\n    \"use strict\";\n    /**\n     * Object used to hold the data that is being dragged during drag and drop operations.\n     *\n     * It may hold one or more data items of different types. For more information about\n     * drag and drop operations and data transfer objects, see\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer\">HTML Drag and Drop API</a>.\n     *\n     * This object is created automatically by the @see:DragDropTouch singleton and is\n     * accessible through the @see:dataTransfer property of all drag events.\n     */\n    var DataTransfer = (function () {\n        function DataTransfer() {\n            this._dropEffect = \"move\";\n            this._effectAllowed = \"all\";\n            this._data = {};\n        }\n        Object.defineProperty(DataTransfer.prototype, \"dropEffect\", {\n            /**\n             * Gets or sets the type of drag-and-drop operation currently selected.\n             * The value must be 'none',  'copy',  'link', or 'move'.\n             */\n            get: function () {\n                return this._dropEffect;\n            },\n            set: function (value) {\n                this._dropEffect = value;\n            },\n            enumerable: true,\n            configurable: true,\n        });\n        Object.defineProperty(DataTransfer.prototype, \"effectAllowed\", {\n            /**\n             * Gets or sets the types of operations that are possible.\n             * Must be one of 'none', 'copy', 'copyLink', 'copyMove', 'link',\n             * 'linkMove', 'move', 'all' or 'uninitialized'.\n             */\n            get: function () {\n                return this._effectAllowed;\n            },\n            set: function (value) {\n                this._effectAllowed = value;\n            },\n            enumerable: true,\n            configurable: true,\n        });\n        Object.defineProperty(DataTransfer.prototype, \"types\", {\n            /**\n             * Gets an array of strings giving the formats that were set in the @see:dragstart event.\n             */\n            get: function () {\n                return Object.keys(this._data);\n            },\n            enumerable: true,\n            configurable: true,\n        });\n        /**\n         * Removes the data associated with a given type.\n         *\n         * The type argument is optional. If the type is empty or not specified, the data\n         * associated with all types is removed. If data for the specified type does not exist,\n         * or the data transfer contains no data, this method will have no effect.\n         *\n         * @param type Type of data to remove.\n         */\n        DataTransfer.prototype.clearData = function (type) {\n            if (type != null) {\n                delete this._data[type.toLowerCase()];\n            } else {\n                this._data = {};\n            }\n        };\n        /**\n         * Retrieves the data for a given type, or an empty string if data for that type does\n         * not exist or the data transfer contains no data.\n         *\n         * @param type Type of data to retrieve.\n         */\n        DataTransfer.prototype.getData = function (type) {\n            return this._data[type.toLowerCase()] || \"\";\n        };\n        /**\n         * Set the data for a given type.\n         *\n         * For a list of recommended drag types, please see\n         * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Recommended_Drag_Types.\n         *\n         * @param type Type of data to add.\n         * @param value Data to add.\n         */\n        DataTransfer.prototype.setData = function (type, value) {\n            this._data[type.toLowerCase()] = value;\n        };\n        /**\n         * Set the image to be used for dragging if a custom one is desired.\n         *\n         * @param img An image element to use as the drag feedback image.\n         * @param offsetX The horizontal offset within the image.\n         * @param offsetY The vertical offset within the image.\n         */\n        DataTransfer.prototype.setDragImage = function (img, offsetX, offsetY) {\n            var ddt = (DragDropTouch as any)._instance;\n            ddt._imgCustom = img;\n            ddt._imgOffset = { x: offsetX, y: offsetY };\n        };\n        return DataTransfer;\n    })();\n    DragDropTouch_1.DataTransfer = DataTransfer;\n    /**\n     * Defines a class that adds support for touch-based HTML5 drag/drop operations.\n     *\n     * The @see:DragDropTouch class listens to touch events and raises the\n     * appropriate HTML5 drag/drop events as if the events had been caused\n     * by mouse actions.\n     *\n     * The purpose of this class is to enable using existing, standard HTML5\n     * drag/drop code on mobile devices running IOS or Android.\n     *\n     * To use, include the DragDropTouch.js file on the page. The class will\n     * automatically start monitoring touch events and will raise the HTML5\n     * drag drop events (dragstart, dragenter, dragleave, drop, dragend) which\n     * should be handled by the application.\n     *\n     * For details and examples on HTML drag and drop, see\n     * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_operations.\n     */\n    const DragDropTouch = (function () {\n        /**\n         * Initializes the single instance of the @see:DragDropTouch class.\n         */\n        function DragDropTouch() {\n            this._lastClick = 0;\n            // enforce singleton pattern\n            if ((DragDropTouch as any)._instance) {\n                throw \"DragDropTouch instance already created.\";\n            }\n            // detect passive event support\n            // https://github.com/Modernizr/Modernizr/issues/1894\n            var supportsPassive = false;\n            safeDocument?.addEventListener(\"test\", function () {}, {\n                get passive() {\n                    supportsPassive = true;\n                    return true;\n                },\n            });\n            // listen to touch events\n            if (safeNavigator?.maxTouchPoints) {\n                var d = safeDocument,\n                    ts = this._touchstart.bind(this),\n                    tm = this._touchmove.bind(this),\n                    te = this._touchend.bind(this),\n                    opt = supportsPassive ? { passive: false, capture: false } : false;\n                d.addEventListener(\"touchstart\", ts, opt);\n                d.addEventListener(\"touchmove\", tm, opt);\n                d.addEventListener(\"touchend\", te);\n                d.addEventListener(\"touchcancel\", te);\n            }\n        }\n        /**\n         * Gets a reference to the @see:DragDropTouch singleton.\n         */\n        DragDropTouch.getInstance = function () {\n            return (DragDropTouch as any)._instance;\n        };\n        // ** event handlers\n        DragDropTouch.prototype._touchstart = function (e) {\n            var _this = this;\n            if (this._shouldHandle(e)) {\n                // raise double-click and prevent zooming\n                if (Date.now() - this._lastClick < (DragDropTouch as any)._DBLCLICK) {\n                    if (this._dispatchEvent(e, \"dblclick\", e.target)) {\n                        e.preventDefault();\n                        this._reset();\n                        return;\n                    }\n                }\n                // clear all variables\n                this._reset();\n                // get nearest draggable element\n                var src = this._closestDraggable(e.target);\n                if (src) {\n                    // give caller a chance to handle the hover/move events\n                    if (!this._dispatchEvent(e, \"mousemove\", e.target) && !this._dispatchEvent(e, \"mousedown\", e.target)) {\n                        // get ready to start dragging\n                        this._dragSource = src;\n                        this._ptDown = this._getPoint(e);\n                        this._lastTouch = e;\n                        e.preventDefault();\n                        // show context menu if the user hasn't started dragging after a while\n                        setTimeout(function () {\n                            if (_this._dragSource == src && _this._img == null) {\n                                if (_this._dispatchEvent(e, \"contextmenu\", src)) {\n                                    _this._reset();\n                                }\n                            }\n                        }, (DragDropTouch as any)._CTXMENU);\n                        if ((DragDropTouch as any)._ISPRESSHOLDMODE) {\n                            this._pressHoldInterval = setTimeout(function () {\n                                _this._isDragEnabled = true;\n                                _this._touchmove(e);\n                            }, (DragDropTouch as any)._PRESSHOLDAWAIT);\n                        }\n                    }\n                }\n            }\n        };\n        DragDropTouch.prototype._touchmove = function (e) {\n            if (this._shouldCancelPressHoldMove(e)) {\n                this._reset();\n                return;\n            }\n            if (this._shouldHandleMove(e) || this._shouldHandlePressHoldMove(e)) {\n                // see if target wants to handle move\n                var target = this._getTarget(e);\n                if (this._dispatchEvent(e, \"mousemove\", target)) {\n                    this._lastTouch = e;\n                    e.preventDefault();\n                    return;\n                }\n                // start dragging\n                if (this._dragSource && !this._img && this._shouldStartDragging(e)) {\n                    this._dispatchEvent(e, \"dragstart\", this._dragSource);\n                    this._createImage(e);\n                    this._dispatchEvent(e, \"dragenter\", target);\n                }\n                // continue dragging\n                if (this._img) {\n                    this._lastTouch = e;\n                    e.preventDefault(); // prevent scrolling\n                    this._dispatchEvent(e, \"drag\", this._dragSource);\n                    if (target != this._lastTarget) {\n                        this._dispatchEvent(this._lastTouch, \"dragleave\", this._lastTarget);\n                        this._dispatchEvent(e, \"dragenter\", target);\n                        this._lastTarget = target;\n                    }\n                    this._moveImage(e);\n                    this._isDropZone = this._dispatchEvent(e, \"dragover\", target);\n                }\n            }\n        };\n        DragDropTouch.prototype._touchend = function (e) {\n            if (this._shouldHandle(e)) {\n                // see if target wants to handle up\n                if (this._dispatchEvent(this._lastTouch, \"mouseup\", e.target)) {\n                    e.preventDefault();\n                    return;\n                }\n                // user clicked the element but didn't drag, so clear the source and simulate a click\n                if (!this._img) {\n                    this._dragSource = null;\n                    this._dispatchEvent(this._lastTouch, \"click\", e.target);\n                    this._lastClick = Date.now();\n                }\n                // finish dragging\n                this._destroyImage();\n                if (this._dragSource) {\n                    if (e.type.indexOf(\"cancel\") < 0 && this._isDropZone) {\n                        this._dispatchEvent(this._lastTouch, \"drop\", this._lastTarget);\n                    }\n                    this._dispatchEvent(this._lastTouch, \"dragend\", this._dragSource);\n                    this._reset();\n                }\n            }\n        };\n        // ** utilities\n        // ignore events that have been handled or that involve more than one touch\n        DragDropTouch.prototype._shouldHandle = function (e) {\n            return e && !e.defaultPrevented && e.touches && e.touches.length < 2;\n        };\n\n        // use regular condition outside of press & hold mode\n        DragDropTouch.prototype._shouldHandleMove = function (e) {\n            return !(DragDropTouch as any)._ISPRESSHOLDMODE && this._shouldHandle(e);\n        };\n\n        // allow to handle moves that involve many touches for press & hold\n        DragDropTouch.prototype._shouldHandlePressHoldMove = function (e) {\n            return (DragDropTouch as any)._ISPRESSHOLDMODE && this._isDragEnabled && e && e.touches && e.touches.length;\n        };\n\n        // reset data if user drags without pressing & holding\n        DragDropTouch.prototype._shouldCancelPressHoldMove = function (e) {\n            return (DragDropTouch as any)._ISPRESSHOLDMODE && !this._isDragEnabled && this._getDelta(e) > (DragDropTouch as any)._PRESSHOLDMARGIN;\n        };\n\n        // start dragging when specified delta is detected\n        DragDropTouch.prototype._shouldStartDragging = function (e) {\n            var delta = this._getDelta(e);\n            return delta > (DragDropTouch as any)._THRESHOLD || ((DragDropTouch as any)._ISPRESSHOLDMODE && delta >= (DragDropTouch as any)._PRESSHOLDTHRESHOLD);\n        };\n\n        // clear all members\n        DragDropTouch.prototype._reset = function () {\n            this._destroyImage();\n            this._dragSource = null;\n            this._lastTouch = null;\n            this._lastTarget = null;\n            this._ptDown = null;\n            this._isDragEnabled = false;\n            this._isDropZone = false;\n            this._dataTransfer = new DataTransfer();\n            clearInterval(this._pressHoldInterval);\n        };\n        // get point for a touch event\n        DragDropTouch.prototype._getPoint = function (e, page) {\n            if (e && e.touches) {\n                e = e.touches[0];\n            }\n            return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };\n        };\n        // get distance between the current touch event and the first one\n        DragDropTouch.prototype._getDelta = function (e) {\n            if ((DragDropTouch as any)._ISPRESSHOLDMODE && !this._ptDown) {\n                return 0;\n            }\n            var p = this._getPoint(e);\n            return Math.abs(p.x - this._ptDown.x) + Math.abs(p.y - this._ptDown.y);\n        };\n        // get the element at a given touch event\n        DragDropTouch.prototype._getTarget = function (e) {\n            var pt = this._getPoint(e),\n                el = safeDocument?.elementFromPoint(pt.x, pt.y);\n            while (el && getComputedStyle(el).pointerEvents == \"none\") {\n                el = el.parentElement;\n            }\n            return el;\n        };\n        // create drag image from source element\n        DragDropTouch.prototype._createImage = function (e) {\n            // just in case...\n            if (this._img) {\n                this._destroyImage();\n            }\n            // create drag image from custom element or drag source\n            var src = this._imgCustom || this._dragSource;\n            this._img = src.cloneNode(true);\n            this._copyStyle(src, this._img);\n            this._img.style.top = this._img.style.left = \"-9999px\";\n            // if creating from drag source, apply offset and opacity\n            if (!this._imgCustom) {\n                var rc = src.getBoundingClientRect(),\n                    pt = this._getPoint(e);\n                this._imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };\n                this._img.style.opacity = (DragDropTouch as any)._OPACITY.toString();\n            }\n            // add image to document\n            this._moveImage(e);\n            safeDocument?.body.appendChild(this._img);\n        };\n        // dispose of drag image element\n        DragDropTouch.prototype._destroyImage = function () {\n            if (this._img && this._img.parentElement) {\n                this._img.parentElement.removeChild(this._img);\n            }\n            this._img = null;\n            this._imgCustom = null;\n        };\n        // move the drag image element\n        DragDropTouch.prototype._moveImage = function (e) {\n            var _this = this;\n            requestAnimationFrame(function () {\n                if (_this._img) {\n                    var pt = _this._getPoint(e, true),\n                        s = _this._img.style;\n                    s.position = \"absolute\";\n                    s.pointerEvents = \"none\";\n                    s.zIndex = \"999999\";\n                    s.left = Math.round(pt.x - _this._imgOffset.x) + \"px\";\n                    s.top = Math.round(pt.y - _this._imgOffset.y) + \"px\";\n                }\n            });\n        };\n        // copy properties from an object to another\n        DragDropTouch.prototype._copyProps = function (dst, src, props) {\n            for (var i = 0; i < props.length; i++) {\n                var p = props[i];\n                dst[p] = src[p];\n            }\n        };\n        DragDropTouch.prototype._copyStyle = function (src, dst) {\n            // remove potentially troublesome attributes\n            (DragDropTouch as any)._rmvAtts.forEach(function (att) {\n                dst.removeAttribute(att);\n            });\n            // copy canvas content\n            if (src instanceof HTMLCanvasElement) {\n                var cSrc = src,\n                    cDst = dst;\n                cDst.width = cSrc.width;\n                cDst.height = cSrc.height;\n                cDst.getContext(\"2d\").drawImage(cSrc, 0, 0);\n            }\n            // copy style (without transitions)\n            var cs = getComputedStyle(src);\n            for (var i = 0; i < cs.length; i++) {\n                var key = cs[i];\n                if (key.indexOf(\"transition\") < 0) {\n                    dst.style[key] = cs[key];\n                }\n            }\n            dst.style.pointerEvents = \"none\";\n            // and repeat for all children\n            for (var i = 0; i < src.children.length; i++) {\n                this._copyStyle(src.children[i], dst.children[i]);\n            }\n        };\n        DragDropTouch.prototype._dispatchEvent = function (e, type, target) {\n            if (e && target) {\n                var evt = safeDocument?.createEvent(\"Event\"),\n                    t = e.touches ? e.touches[0] : e;\n                evt.initEvent(type, true, true);\n                (evt as any).button = 0;\n                (evt as any).which = (evt as any).buttons = 1;\n                this._copyProps(evt, e, (DragDropTouch as any)._kbdProps);\n                this._copyProps(evt, t, (DragDropTouch as any)._ptProps);\n                (evt as any).dataTransfer = this._dataTransfer;\n                target.dispatchEvent(evt);\n                return evt.defaultPrevented;\n            }\n            return false;\n        };\n        // gets an element's closest draggable ancestor\n        DragDropTouch.prototype._closestDraggable = function (e) {\n            for (; e; e = e.parentElement) {\n                if (e.hasAttribute(\"draggable\") && e.draggable) {\n                    return e;\n                }\n            }\n            return null;\n        };\n        return DragDropTouch;\n    })();\n    /*private*/ (DragDropTouch as any)._instance = new DragDropTouch(); // singleton\n    // constants\n    (DragDropTouch as any)._THRESHOLD = 5; // pixels to move before drag starts\n    (DragDropTouch as any)._OPACITY = 0.5; // drag image opacity\n    (DragDropTouch as any)._DBLCLICK = 500; // max ms between clicks in a double click\n    (DragDropTouch as any)._CTXMENU = 900; // ms to hold before raising 'contextmenu' event\n    (DragDropTouch as any)._ISPRESSHOLDMODE = false; // decides of press & hold mode presence\n    (DragDropTouch as any)._PRESSHOLDAWAIT = 400; // ms to wait before press & hold is detected\n    (DragDropTouch as any)._PRESSHOLDMARGIN = 25; // pixels that finger might shiver while pressing\n    (DragDropTouch as any)._PRESSHOLDTHRESHOLD = 0; // pixels to move before drag starts\n    // copy styles/attributes from drag source to drag image element\n    (DragDropTouch as any)._rmvAtts = \"id,class,style,draggable\".split(\",\");\n    // synthesize and dispatch an event\n    // returns true if the event has been handled (e.preventDefault == true)\n    (DragDropTouch as any)._kbdProps = \"altKey,ctrlKey,metaKey,shiftKey\".split(\",\");\n    (DragDropTouch as any)._ptProps = \"pageX,pageY,clientX,clientY,screenX,screenY,offsetX,offsetY\".split(\",\");\n    DragDropTouch_1.DragDropTouch = DragDropTouch;\n})(DragDropTouch || (DragDropTouch = {}));\n","export default \"import React from \\\"react\\\";\\nimport classnames from \\\"classnames\\\";\\nimport { SortableItemProps } from \\\"./SortableItem\\\";\\nimport \\\"./dragtouch.polyfills\\\";\\nimport \\\"./sortable-list.scss\\\";\\n\\nconst dragAndDropIcon: JSX.Element = (\\n    <svg width=\\\"10px\\\" fill=\\\"currentColor\\\" height=\\\"16px\\\" viewBox=\\\"0 0 10 16\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlnsXlink=\\\"http://www.w3.org/1999/xlink\\\">\\n        <g id=\\\"Symbols\\\" stroke=\\\"none\\\" strokeWidth=\\\"1\\\" fill=\\\"none\\\" fillRule=\\\"evenodd\\\">\\n            <g id=\\\"Group\\\" fill=\\\"currentColor\\\">\\n                <circle id=\\\"Oval\\\" cx=\\\"2\\\" cy=\\\"2\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-2\\\" cx=\\\"2\\\" cy=\\\"8\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-4\\\" cx=\\\"2\\\" cy=\\\"14\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy\\\" cx=\\\"8\\\" cy=\\\"2\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-3\\\" cx=\\\"8\\\" cy=\\\"8\\\" r=\\\"2\\\" />\\n                <circle id=\\\"Oval-Copy-5\\\" cx=\\\"8\\\" cy=\\\"14\\\" r=\\\"2\\\" />\\n            </g>\\n        </g>\\n    </svg>\\n);\\n\\nexport type SortableListProps = JSX.IntrinsicElements[\\\"div\\\"] & {\\n    /** on sort callback */\\n    onSort: (list: Array<string>) => void;\\n    /** disable sorting */\\n    disabled?: boolean;\\n};\\n\\ntype PositionDelta = {\\n    x: number;\\n    y: number;\\n};\\n\\ntype OrderItem = Pick<SortableItemWrapperProps, \\\"disabled\\\" | \\\"uniqueKey\\\">;\\n\\n/** The component allows for sorting list by drag and drop. */\\nexport const SortableList: React.FC<SortableListProps> = ({ onSort, className, disabled, ...props }: React.PropsWithChildren<SortableListProps>) => {\\n    const dragContainerRef = React.useRef<HTMLDivElement>();\\n    const [defaultOrders, setDefaultOrders] = React.useState<OrderItem[]>([]);\\n    const [draggingOrders, setDraggingOrders] = React.useState<OrderItem[]>(defaultOrders);\\n    const [currentItemNode, setCurrentItemNode] = React.useState<HTMLDivElement>(null);\\n    const [currentItemIndex, setCurrentItemIndex] = React.useState<number>(null);\\n    const [delta, setDelta] = React.useState<PositionDelta>({ x: 0, y: 0 });\\n    const [dragNode, setDragNode] = React.useState<HTMLElement>(null);\\n    const [isDragging, setIsDragging] = React.useState<boolean>(false);\\n    const [isTranslating, setIsTranslating] = React.useState<boolean>(false);\\n    const [affectedIndex, setAffectedIndex] = React.useState<number>(null);\\n    const [affectedNode, setAffectedNode] = React.useState<HTMLDivElement>(null);\\n\\n    /**\\n     * when user clicks on sortable item, set initial delta and selected item\\n     * @param event mouse event\\n     * @param index selected index\\n     */\\n    const onMouseDown = (event: React.MouseEvent<HTMLDivElement, MouseEvent> | React.TouchEvent<HTMLDivElement>, index: number) => {\\n        const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\\\".sortable-item-wrapper\\\");\\n        const position: React.MouseEvent = ((event as React.TouchEvent).touches ? (event as React.TouchEvent).touches[0] : event) as React.MouseEvent;\\n        setDelta({\\n            x: position.pageX - itemParentNode.getBoundingClientRect().left,\\n            y: position.pageY - itemParentNode.getBoundingClientRect().top,\\n        });\\n        setCurrentItemIndex(index);\\n        setCurrentItemNode(itemParentNode);\\n    };\\n\\n    /**\\n     * on drag initiated, set the ghost item\\n     * @param event drag event\\n     */\\n    const onDragStart = React.useCallback(\\n        (event: React.DragEvent<HTMLDivElement>) => {\\n            setIsDragging(() => {\\n                const clonedNode: HTMLElement = currentItemNode.cloneNode(true) as HTMLElement;\\n                clonedNode.classList.remove(\\\"is-active\\\");\\n                clonedNode.classList.add(\\\"on-drag\\\");\\n                clonedNode.style.width = `${currentItemNode.getBoundingClientRect().width}px`;\\n                clonedNode.style.height = `${currentItemNode.getBoundingClientRect().height}px`;\\n                document.body.appendChild(clonedNode);\\n                event.dataTransfer.setDragImage(clonedNode, delta.x, delta.y);\\n                event.dataTransfer.effectAllowed = \\\"move\\\";\\n                setDragNode(clonedNode);\\n                return true;\\n            });\\n        },\\n        [currentItemNode]\\n    );\\n\\n    /**\\n     * when the dragged item is dragged over another sortable item, check if the overlapped element fulfills criteria to be swapped\\n     * @param event drag event\\n     * @param index overlapped index\\n     */\\n    const onDragOver = React.useCallback(\\n        (event: React.DragEvent<HTMLDivElement>, index: number) => {\\n            event.preventDefault(); // to prevent ghost image for reverting to original position\\n            event.dataTransfer.dropEffect = \\\"move\\\";\\n            const activeNodeRect: DOMRect = currentItemNode.getBoundingClientRect();\\n            const itemParentNode: HTMLDivElement = (event.target as HTMLDivElement).closest(\\\".sortable-item-wrapper\\\");\\n            const nodeRect: DOMRect = itemParentNode.getBoundingClientRect();\\n            const ghostImagePositionTop: number = event.clientY - delta.y;\\n            const ghostImagePositionBottom: number = ghostImagePositionTop + activeNodeRect.height; // get ghost image's actual position\\n            const isAboveGhostImage: boolean = nodeRect.top <= ghostImagePositionTop;\\n            let positionDifference: number = nodeRect.top - ghostImagePositionBottom;\\n            if (isAboveGhostImage) {\\n                positionDifference = ghostImagePositionTop - nodeRect.bottom;\\n            }\\n            const isHalfCoverage: boolean = Math.abs(positionDifference) / nodeRect.height >= 0.5; // only trigger swapping when overlapped coverage is more than 50%\\n            const isOverlapped: boolean = isHalfCoverage && !isTranslating && itemParentNode.className.indexOf(\\\"on-drag\\\") === -1;\\n            itemParentNode.style.transform = null;\\n            if (isOverlapped) {\\n                // if the overlapped item fulfills criteria, initiate animation\\n                setIsTranslating(true);\\n                itemParentNode.style.transform = `translate3d(0, ${isAboveGhostImage ? \\\"\\\" : \\\"-\\\"}${itemParentNode.offsetHeight}px, 0)`;\\n                setAffectedNode(itemParentNode);\\n                setAffectedIndex(index);\\n            }\\n        },\\n        [currentItemNode, delta, setIsTranslating, setAffectedNode, setAffectedIndex]\\n    );\\n\\n    /** sort dragging order on transition end */\\n    const onTransitionEnd = React.useCallback(() => {\\n        if (affectedNode) {\\n            setDraggingOrders((oldOrders: OrderItem[]) => {\\n                const newList: OrderItem[] = oldOrders.slice(0);\\n                affectedNode.style.transform = null;\\n                let itemIndex: number = currentItemIndex;\\n                const originalItem: OrderItem = newList.find(({ uniqueKey }: OrderItem, index: number) => {\\n                    itemIndex = index;\\n                    return uniqueKey === defaultOrders[currentItemIndex].uniqueKey;\\n                });\\n                newList[itemIndex] = newList[affectedIndex]; // swap overlapped\\n                newList[affectedIndex] = originalItem;\\n                setAffectedIndex(null);\\n                setAffectedNode(null);\\n                setIsTranslating(false);\\n                return newList;\\n            });\\n        }\\n    }, [affectedNode, affectedIndex, setDraggingOrders, setAffectedIndex, setAffectedNode, setIsTranslating]);\\n\\n    /**\\n     * on drag end, remove appended ghost image and style, fire on sort callback\\n     * @param event drag event\\n     */\\n    const onDragEnd = React.useCallback(\\n        (event: React.DragEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement> | React.MouseEvent<HTMLDivElement>) => {\\n            setIsDragging(() => {\\n                event.preventDefault(); // to prevent ghost image for reverting to original position\\n                event.stopPropagation();\\n                Array.from(dragContainerRef.current.children).forEach((element: HTMLElement) => {\\n                    element.style.transform = null;\\n                });\\n                setCurrentItemIndex(null);\\n                setCurrentItemNode(null);\\n                onSort(draggingOrders.map(({ uniqueKey }: OrderItem) => uniqueKey));\\n                setDefaultOrders(draggingOrders);\\n                dragNode?.remove();\\n                return false;\\n            });\\n        },\\n        [dragContainerRef, draggingOrders, dragNode, setIsDragging, setCurrentItemIndex, setCurrentItemNode, onSort, setDefaultOrders]\\n    );\\n\\n    React.useEffect(() => {\\n        setDefaultOrders(() => {\\n            const newOrderList: OrderItem[] = React.Children.toArray(props.children)\\n                .filter((item: React.ReactChild) => React.isValidElement<React.FC<SortableItemProps>>(item) && (item?.type as any)?.displayName === \\\"SortableItem\\\")\\n                .map(({ props }: React.ReactElement<SortableItemProps>) => ({ uniqueKey: props.uniqueKey, disabled: props.disabled }));\\n            if (newOrderList.length === 0) {\\n                console.warn(\\\"Please pass at least one SortableItem element to make SortableList works\\\");\\n            }\\n            return newOrderList;\\n        });\\n    }, [props.children]);\\n\\n    React.useEffect(() => {\\n        setDraggingOrders(defaultOrders);\\n    }, [defaultOrders]);\\n\\n    return (\\n        <div {...props} className={classnames(\\\"rc\\\", \\\"sortable-list\\\", className, { disabled })}>\\n            <div className=\\\"drop-container\\\" ref={dragContainerRef}>\\n                {(currentItemIndex === null ? defaultOrders : draggingOrders).map((item: OrderItem, index) => (\\n                    <SortableItemWrapper\\n                        key={index}\\n                        uniqueKey={item.uniqueKey}\\n                        disabled={disabled || item.disabled}\\n                        isActive={currentItemIndex !== null && item === defaultOrders[currentItemIndex]}\\n                        isDragging={isDragging}\\n                        className=\\\"sortable-item-wrapper\\\"\\n                        onMouseDown={(event: React.MouseEvent<HTMLDivElement, MouseEvent>) => onMouseDown(event, index)}\\n                        onTouchStart={(event: React.TouchEvent<HTMLDivElement>) => onMouseDown(event, index)}\\n                        onMouseUp={onDragEnd}\\n                        onTouchEnd={onDragEnd}\\n                        onDragStart={onDragStart}\\n                        onDragOver={isTranslating ? null : (event: React.DragEvent<HTMLDivElement>) => onDragOver(event, index)}\\n                        onDragEnd={onDragEnd}\\n                        onTransitionEnd={onTransitionEnd}\\n                    >\\n                        {React.Children.map(props.children, (Child: React.ReactElement<SortableItemProps>) => {\\n                            const { uniqueKey }: SortableItemProps = Child.props;\\n                            const isDisabled: boolean = disabled || item.disabled;\\n                            return item.uniqueKey === uniqueKey && React.isValidElement<React.FC<SortableItemProps>>(Child)\\n                                ? React.cloneElement(Child, {\\n                                      disabled: isDisabled,\\n                                      \\\"aria-disabled\\\": isDisabled,\\n                                  })\\n                                : null;\\n                        })}\\n                    </SortableItemWrapper>\\n                ))}\\n            </div>\\n        </div>\\n    );\\n};\\n\\ntype SortableItemWrapperProps = SortableItemProps &\\n    JSX.IntrinsicElements[\\\"div\\\"] & {\\n        isActive?: boolean;\\n        disabled?: boolean;\\n        isDragging?: boolean;\\n    };\\n\\nconst SortableItemWrapper: React.FC<SortableItemWrapperProps> = ({\\n    isActive,\\n    isDragging,\\n    className,\\n    disabled,\\n    children,\\n    uniqueKey,\\n    onDragStart,\\n    onDragOver,\\n    onDragEnd,\\n    onTransitionEnd,\\n    onMouseDown,\\n    onMouseUp,\\n    onTouchEnd,\\n    onTouchStart,\\n    ...props\\n}: React.PropsWithChildren<SortableItemWrapperProps>) => {\\n    return (\\n        <div\\n            {...props}\\n            className={classnames(\\\"rc\\\", \\\"sortable-item-wrapper\\\", className, { \\\"is-active\\\": isActive && isDragging, disabled })}\\n            data-value={uniqueKey}\\n            onTransitionEnd={disabled ? null : onTransitionEnd}\\n            onDragOver={disabled ? null : isActive ? (event: React.DragEvent) => event.preventDefault() : onDragOver}\\n        >\\n            <div className=\\\"sort-item-content\\\">{children}</div>\\n            <div\\n                className=\\\"drag-icon\\\"\\n                draggable={isActive && !disabled}\\n                onMouseUp={isDragging || disabled ? null : onMouseUp}\\n                onTouchEnd={isDragging || disabled ? null : onTouchEnd}\\n                onMouseDown={disabled ? null : onMouseDown}\\n                onTouchStart={disabled ? null : onTouchStart}\\n                onDragStart={isActive || !disabled ? onDragStart : null}\\n                onDragEnd={isDragging || !disabled ? onDragEnd : null}\\n            >\\n                {dragAndDropIcon}\\n            </div>\\n        </div>\\n    );\\n};\\n\";"],"names":["dragAndDropIcon","width","fill","height","viewBox","version","xmlns","xmlnsXlink","id","stroke","strokeWidth","fillRule","cx","cy","r","SortableList","onSort","className","disabled","props","dragContainerRef","React","defaultOrders","setDefaultOrders","draggingOrders","setDraggingOrders","currentItemNode","setCurrentItemNode","currentItemIndex","setCurrentItemIndex","x","y","delta","setDelta","dragNode","setDragNode","isDragging","setIsDragging","isTranslating","setIsTranslating","affectedIndex","setAffectedIndex","affectedNode","setAffectedNode","onMouseDown","event","index","itemParentNode","target","closest","position","touches","pageX","getBoundingClientRect","left","pageY","top","onDragStart","clonedNode","cloneNode","classList","remove","add","style","document","body","appendChild","dataTransfer","setDragImage","effectAllowed","onDragOver","preventDefault","dropEffect","activeNodeRect","nodeRect","ghostImagePositionTop","clientY","ghostImagePositionBottom","isAboveGhostImage","positionDifference","bottom","isOverlapped","Math","abs","indexOf","transform","offsetHeight","onTransitionEnd","oldOrders","newList","slice","itemIndex","originalItem","find","uniqueKey","onDragEnd","stopPropagation","Array","from","current","children","forEach","element","map","newOrderList","filter","item","type","displayName","length","console","warn","classnames","ref","SortableItemWrapper","key","isActive","onTouchStart","onMouseUp","onTouchEnd","Child","isDisabled","draggable","SortableItem","importString","require","value","setValue","label","checked","array","setArray","useDynamicForm","items","controlType","renderControls","controls","disabledItem","floor","random","Docs","mainFile","example","list","oldArray","sort","a","b","simple","Checkbox","name","onChange","checkbox","code","DragDropTouch","safeDocument","safeNavigator","navigator","DragDropTouch_1","DataTransfer","this","_dropEffect","_effectAllowed","_data","Object","defineProperty","prototype","get","set","enumerable","configurable","keys","clearData","toLowerCase","getData","setData","img","offsetX","offsetY","ddt","_instance","_imgCustom","_imgOffset","_lastClick","supportsPassive","addEventListener","maxTouchPoints","d","ts","_touchstart","bind","tm","_touchmove","te","_touchend","opt","passive","capture","getInstance","e","_this","_shouldHandle","Date","now","_DBLCLICK","_dispatchEvent","_reset","src","_closestDraggable","_dragSource","_ptDown","_getPoint","_lastTouch","setTimeout","_img","_CTXMENU","_ISPRESSHOLDMODE","_pressHoldInterval","_isDragEnabled","_PRESSHOLDAWAIT","_shouldCancelPressHoldMove","_shouldHandleMove","_shouldHandlePressHoldMove","_getTarget","_shouldStartDragging","_createImage","_lastTarget","_moveImage","_isDropZone","_destroyImage","defaultPrevented","_getDelta","_PRESSHOLDMARGIN","_THRESHOLD","_PRESSHOLDTHRESHOLD","_dataTransfer","clearInterval","page","clientX","p","pt","el","elementFromPoint","getComputedStyle","pointerEvents","parentElement","_copyStyle","rc","opacity","_OPACITY","toString","removeChild","requestAnimationFrame","s","zIndex","round","_copyProps","dst","i","_rmvAtts","att","removeAttribute","HTMLCanvasElement","cSrc","cDst","getContext","drawImage","cs","evt","createEvent","t","initEvent","button","which","buttons","_kbdProps","_ptProps","dispatchEvent","hasAttribute","split"],"sourceRoot":""}